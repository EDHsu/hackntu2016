{
    "collab_server" : "",
    "contents" : "##########################################################################\n# You may cite these labs as follows: McFarland, Daniel, Solomon Messing,\n# Mike Nowak, and Sean Westwood. 2010. \"Social Network Analysis          \n# Labs in R.\" Stanford University.                                       \n##########################################################################\n \n \n##########################################################################\n# LAB 1 - Introductory Lab                                              \n# The point of this lab is to introduce students to the packages of          \n# SNA and Igraph, to cover some basic R commands, to load and manage      \n# data, to generate graph visualizations, and to export the data for \n# use elsewhere.                   \n##########################################################################\n \n###\n# 0. R BASICS \n###\n \n# Any line starting with # is a \"comment\" line and is ignored by\n# R. Any other line is treated as a command. Run commands by \n# copying and pasting them into the R Console.\n#\n# If (when) you get confused, a good place to start is with R's\n# built-in help functionality. R offers detailed help files for\n# each function and each package. To access help type ?[function\n# or package name] in the console. For example, for help on the\n# \"sum\" function, type:\n?sum\n \n# To install all packages need for Social Network Analysis \n# Labs in R, uncomment and run the following code:\n \n#source(\"http://sna.stanford.edu/setup.R\")\n\n# You only need to run this once per computer!\n \n# To load the packages from , you need to call the \"library\"\n# command. Note that you need to do this each session; packages\n# don't load automatically by default (though you can set this \n# as a preference if you'd like).\n \n# For this lab, we will use the \"igraph\" package.\n# A manual is available at \n# http://cran.r-project.org/web/packages/igraph/igraph.pdf.\nlibrary(igraph) \n \n# Sometimes, different packages overlap in functionality and \n# cause unexpected behavior when both are loaded simultaneously.\n# If you ever want to remove an existing library, use the \n# \"detach\" command:\n#\n# detach(package:igraph)\n \n# IMPORTANT NOTE: Unlike in most languages, R objects are numbered\n# from 1 instead of 0, so if you want the first element in a\n# vector, you would reference it by vector_name[1]. HOWEVER,\n# igraph objects are numbered starting from 0. This can lead to \n# lots of confusion, since it's not always obvious at first which \n# objects are native to R and which belong to igraph. \n \n \n###\n# 1. LOADING DATA\n###\n \n# The <- operator sets a variable equal to something. In this case,\n# we will set a number of basic R data structures, called \"data \n# frames,\" to hold the contents of the files we will open. \n#\n# read.table() is the most common R command for loading data from\n# files in which values are in tabular format. The function loads\n# the table into a data frame object, which is the basic data type\n# for most operations in R. By default, R assumes that the table\n# has no header and is delimited by any white space; these\n# settings are fine for our purposes here.\n\n# 從網路上載入資料\n# One handy aspect of R is that you can read in data from a URL \n# directly by referencing the URL in the read.table() function,\n# as follows: \n#advice_data_frame <- read.table('http://sna.stanford.edu/sna_R_labs/data/Krack-High-Tec-edgelist-Advice.txt')\n#friendship_data_frame <- read.table('http://sna.stanford.edu/sna_R_labs/data/Krack-High-Tec-edgelist-Friendship.txt')\nreports_to_data_frame <- read.table('http://sna.stanford.edu/sna_R_labs/data/Krack-High-Tec-edgelist-ReportsTo.txt')\n\n# 從本機載入資料 \n# If the files you want to work with are on your local machine, \n# the easiest way to access them is to first set your working \n# directory via the setwd() command, and then reference the \n# files by name:\n#\n# setwd('path/to/your_directory')\n# your_data_frame <- read.table('your_file_name')\n\n# setwd('./lab_1')\nadvice_data_frame <- read.table('Krack-High-Tec-edgelist-Advice.txt')\nfriendship_data_frame <- read.table('Krack-High-Tec-edgelist-Friendship.txt')\n\n# Note that when you set a variable equal to something, if all \n# goes well R will not provide any feedback. To see the data we\n# just loaded, it's necessary to call the variables directly.\nadvice_data_frame\n \n# Since this is a bit long, we can see just the top six rows via\n# head()...\nhead(friendship_data_frame)\n \n# ... or the bottom six rows via tail().\ntail(reports_to_data_frame)\n\n# To view your data in a spreadsheet-like window, use the command 'fix()'. \n# Error here !!!!!\nfix(reports_to_data_frame)\n\n# The attribute data for this lab is in a comma-separated-value\n# (CSV) file. read.csv() loads a CSV file into a data frame\n# object. In this case, we do have a header row, so we set\n# header=T, which tells R that the first row of data contains\n# column names.\nattributes <- read.csv('http://sna.stanford.edu/sna_R_labs/data/Krack-High-Tec-Attributes.csv', header=T)\nattributes\n \n# Other commands may be used to load data from files in different \n# formats. read.delim() is a general function for loading any\n# delimited text file. The default is tab-delimited, but this can \n# be overridden by setting the \"sep\" parameter. For example:\n#\n#     f <- read.delim(\"tab_delimited_file.txt\")\n#     f <- read.delim(\"colon_delimited_file.txt\", sep=':')\n#\n# The 'foreign' package will allow you to read a few other \n# custom data types, such as SPSS files via read.spss() and \n# STATA files via read.dta().\n \n# When data files are part of an R package you can read them as \n# follows:\n#\n# data(kracknets, package = \"NetData\")\n \n# In the future, we will load data this way. However, it is useful \n# to get a sense of how things often must be done in R.\n \n \n###\n# 2.2. LOADING GRAPHS\n###\n \n# For convenience, we can assign column names to our newly \n# imported data frames. c() is a common generic R function that \n# combines its arguments into a single vector.\ncolnames(advice_data_frame) <- c('ego', 'alter', 'advice_tie')\nhead(advice_data_frame)\n \ncolnames(friendship_data_frame) <- c('ego', 'alter', 'friendship_tie')\nhead(friendship_data_frame)\n \ncolnames(reports_to_data_frame) <- c('ego', 'alter', 'reports_to_tie')\nhead(reports_to_data_frame)\n \n# Take a look at each data frame using the 'fix()\" function. Note that you'll \n# need to close each fix window before R will evaluate the next line of code.\n\n# Error here !!!!!\nfix(advice_data_frame)\nfix(friendship_data_frame)\nfix(reports_to_data_frame)\n \n# Before we merge these data, we need to make sure 'ego' and 'alter' are the\n# same across data sets. We can compare each row using the == syntax. \n# The command below should return TRUE for every row if all ego rows\n# are the same for advice and friendship:\nadvice_data_frame$ego == friendship_data_frame$ego\n \n# That's a lot of output to sort through. Instead, we can just have R return \n# which row entries are not equal using the syntax below:\nwhich(advice_data_frame$ego != friendship_data_frame$ego)\n \n# Repeat for other variables\nwhich(advice_data_frame$alter != friendship_data_frame$alter)\nwhich(reports_to_data_frame$alter != friendship_data_frame$alter)\nwhich(reports_to_data_frame$ego != friendship_data_frame$ego)\n \n# Now that we've verified they are all the same, we can combine them into \n# a single data frame. \nkrack_full_data_frame <- cbind(advice_data_frame, \n\tfriendship_data_frame$friendship_tie, \n\treports_to_data_frame$reports_to_tie)\nhead(krack_full_data_frame)\n \n# Notice that the last two variable names are now \n# \"reports_to_data_frame$reports_to_tie\"\n# and \"friendship_data_frame$friendship_tie\". \n# That's a little long. We can rename them\n# as follows:\n\nnames(krack_full_data_frame)[4:5] <- c(\"friendship_tie\", \n\t\"reports_to_tie\")  \nhead(krack_full_data_frame)\n \n# Another way to build the data frame is to use R's \n# data.frame syntax from the start:\nkrack_full_data_frame <- data.frame(ego = advice_data_frame[,1],\n\talter = advice_data_frame[,2],\n\tadvice_tie = advice_data_frame[,3],\n\tfriendship_tie = friendship_data_frame[,3], \n\treports_to_tie = reports_to_data_frame[,3])\nhead(krack_full_data_frame)\n \n \n# Now let's move on to some data processing.\n \n# Reduce to non-zero edges so that the edge list only contains\n# actual ties of some type.\nkrack_full_nonzero_edges <- subset(krack_full_data_frame, \n\t(advice_tie > 0 | friendship_tie > 0 | reports_to_tie > 0))\nhead(krack_full_nonzero_edges)\n \n# Now we can import our data into a \"graph\" object using igraph's \n# graph.data.frame() function. Coercing the data into a graph\n# object is what allows us to perform network-analysis techniques.\nkrack_full <- graph.data.frame(krack_full_nonzero_edges) \nsummary(krack_full)\n \n# By default, graph.data.frame() treats the first two columns of \n# a data frame as an edge list and any remaining columns as \n# edge attributes. Thus, the 232 edges appearing in the summary()\n# output refer to the 232 pairs of vertices that are joined by \n# *any type* of tie. The tie types themselves are listed as edge \n# attributes.\n \n# To get a vector of edges for a specific type of tie, use the \n# get.edge.attribute() function.\nget.edge.attribute(krack_full, 'advice_tie')\nget.edge.attribute(krack_full, 'friendship_tie')\nget.edge.attribute(krack_full, 'reports_to_tie')\n \n# If you would like to symmetrize the network, making all \n# asymmetric ties symmetric, use the as.undirected()\n# function: \nkrack_full_symmetrized <- as.undirected(krack_full, mode='collapse')\nsummary(krack_full_symmetrized)\n \n \n \n###\n# 3. ADDING VERTEX ATTRIBUTES TO A GRAPH OBJECT\n###\n \n# One way to add the attributes to your graph object is to iterate\n# through each attribute and each vertex. This means that we will\n# add one attribute at a time to each vertex in the network.\n#\n# V(krack_full) returns a list of the IDs of each vertex in the \n# graph. names(attributes) returns a list of the column names in\n# the attributes table. The double-for loop tells R to repeat the\n# code between the brackets once for each attribute and once for\n# each vertex.\nfor (i in V(krack_full)) {\n    for (j in names(attributes)) {\n        krack_full <- set.vertex.attribute(krack_full, \n                                           j, \n                                           index = i, \n                                           attributes[i + 1, j])\n    }\n}\n \n# A shorter way is to just read in attribute names when you\n# create the graph object:\n \n# First create a vector of vertex labels, in this case 1:n\nattributes = cbind(1:length(attributes[,1]), attributes)\n \nkrack_full <- graph.data.frame(d = krack_full_nonzero_edges, \n                               vertices = attributes) \n \n# Note that we now have 'AGE,' 'TENURE,' 'LEVEL,' and 'DEPT'\n# listed alongside 'name' as vertex attributes.\nsummary(krack_full)\n \n# We can see a list of the values for a given attribute for all of\n# the actors in the network.\nget.vertex.attribute(krack_full, 'AGE')\nget.vertex.attribute(krack_full, 'TENURE')\nget.vertex.attribute(krack_full, 'LEVEL')\nget.vertex.attribute(krack_full, 'DEPT')\n \n \n###\n# 4. VISUALIZE THE NETWORKS\n###\n \n# We can use R's general-purpose plot() method to generate custom\n# visualizations of the network.\n\n# R only lets us look at one plot at a time.  To make our work easier\n# we will save our plots as PDF files.  To jus create a plot execute \n# the code between the PDF function and \"dev.off()\".\n\n# In order to save PDF files we must tell R where to put them.  We do\n# this with the setwd() command.  You must put the full path to the\n# folder where you will output the files here.\n\n# In OS X you can get this information by selecting the folder, right\n# clicking and selecting \"Get Info.\"  The path is listed under \"Where.\"\n\n# In Windows you can get this information by selecting the folder, right\n# clicking and selecting \"Properties.\"  The path information is listed \n# \"location\".\n\n# example: setwd(\"/Users/seanwestwood/Desktop/lab_1\")\nsetwd(\"\")\n  \n# First, let's plot the network with all possible ties.\npdf(\"1.1_Krackhardt_Full.pdf\")\nplot(krack_full)\ndev.off()\n \n# This is a bit of a jumble, so let's look at the networks for\n# single edge types.\n \n# advice only\nkrack_advice_only <- delete.edges(krack_full, \n    E(krack_full)[get.edge.attribute(krack_full,\n    name = \"advice_tie\") == 0])\nsummary(krack_advice_only)\npdf(\"1.2_Krackhardt_Advice.pdf\")\nplot(krack_advice_only)\ndev.off()\n \n# friendship only\nkrack_friendship_only <- delete.edges(krack_full, \n    E(krack_full)[get.edge.attribute(krack_full, \n    name = \"friendship_tie\") == 0])\nsummary(krack_friendship_only)\npdf(\"1.3_Krackhardt_Friendship.pdf\")\nplot(krack_friendship_only)\ndev.off()\n\n# reports-to only\nkrack_reports_to_only <- delete.edges(krack_full, \n    E(krack_full)[get.edge.attribute(krack_full, \n    name = \"reports_to_tie\") == 0])\nsummary(krack_reports_to_only)\npdf(\"1.4_Krackhardt_Reports.pdf\")\nplot(krack_reports_to_only)\ndev.off()\n \n# Still kind of messy, so let's clean things up a bit. For \n# simplicity, we'll focus on reports_to ties for now.\n \n# First, we can optimize the layout by applying the layout \n# algorithm to the specific set of ties we care about. Here \n# we'll use Fruchterman-Rheingold; other options are \n# described in the igraph help page for \"layout,\" which \n# can be accessed by entering ?layout.\n\nreports_to_layout <- layout.fruchterman.reingold(krack_reports_to_only)\npdf(\"1.5_Krackhardt_Reports_Fruchterman_Reingold.pdf\")\nplot(krack_reports_to_only, \n     layout=reports_to_layout)\ndev.off()\n \n# Now let's color-code vertices by department and clean up the \n# plot by removing vertex labels and shrinking the arrow size. \ndept_vertex_colors = get.vertex.attribute(krack_full,\"DEPT\")\ncolors = c('Black', 'Red', 'Blue', 'Yellow', 'Green')\ndept_vertex_colors[dept_vertex_colors == 0] = colors[1]\ndept_vertex_colors[dept_vertex_colors == 1] = colors[2]\ndept_vertex_colors[dept_vertex_colors == 2] = colors[3]\ndept_vertex_colors[dept_vertex_colors == 3] = colors[4] \ndept_vertex_colors[dept_vertex_colors == 4] = colors[5]\n\npdf(\"1.6_Krackhardt_Reports_Color.pdf\") \nplot(krack_reports_to_only, \n    layout=reports_to_layout, \n    vertex.color=dept_vertex_colors, \n    vertex.label=NA, \n    edge.arrow.size=.5)\ndev.off() \n# Now let's set the vertex size by tenure.\ntenure_vertex_sizes = get.vertex.attribute(krack_full,\"TENURE\")\n\npdf(\"1.7_Krackhardt_Reports_Vertex_Size.pdf\") \nplot(krack_reports_to_only, \n     layout=reports_to_layout, \n     vertex.color=dept_vertex_colors, \n     vertex.label=NA, \n     edge.arrow.size=.5,\n     vertex.size=tenure_vertex_sizes)\ndev.off() \n \n# Now let's incorporate additional tie types. We'll use the \n# layout generated by the reports-to ties but overlay the \n# advice and friendship ties in red and blue.\n\ntie_type_colors = c(rgb(1,0,0,.5), rgb(0,0,1,.5), rgb(0,0,0,.5))\nE(krack_full)$color[ E(krack_full)$advice_tie==1 ] = tie_type_colors[1]\nE(krack_full)$color[ E(krack_full)$friendship_tie==1 ] = tie_type_colors[2]\nE(krack_full)$color[ E(krack_full)$reports_to_tie==1 ] = tie_type_colors[3]\nE(krack_full)$arrow.size=.5 \nV(krack_full)$color = dept_vertex_colors\nV(krack_full)$frame = dept_vertex_colors\n\npdf(\"1.8_Krackhardt_Overlayed_Ties.pdf\")\nplot(krack_full, \n     layout=reports_to_layout, \n     vertex.color=dept_vertex_colors, \n     vertex.label=NA, \n     edge.arrow.size=.5,\n     vertex.size=tenure_vertex_sizes)\n \n \n# Add a legend. Note that the plot window must be open for this to \n# work.\nlegend(1, \n       1.25,\n       legend = c('Advice', \n                  'Friendship',\n                  'Reports To'), \n       col = tie_type_colors, \n       lty=1,\n       cex = .7)\ndev.off() \n \n# Another option for visualizing different network ties relative \n# to one another is to overlay the edges from one tie type on the \n# structure generated by another tie type. Here we can use the\n# reports-to layout but show the friendship ties:\n\npdf(\"1.9_Krackhardt_Overlayed_Structure.pdf\")\nplot(krack_friendship_only, \n     layout=reports_to_layout, \n     vertex.color=dept_vertex_colors, \n     vertex.label=NA, \n     edge.arrow.size=.5,\n     vertex.size=tenure_vertex_sizes, \n     main='Krackhardt High-Tech Managers')\ndev.off() \n \n \n###\n# 5. EXPORT THE NETWORK\n###\n \n# The write.graph() function exports a graph object in various\n# formats readable by other programs. There is no explicit\n# option for a UCINET data type, but you can export the graph\n# as a Pajek object by setting the 'format' parameter to 'pajek.'\n# Note that the file will appear in whichever directory is set \n# as the default in R's preferences, unless you previously \n# changed this via setwd().\nwrite.graph(krack_full, file='krack_full.dl', format=\"pajek\")\n \n# For a more general file type (e.g., importable to Excel),\n# use the \"edgelist\" format. Note that neither of these will\n# write the attributes; only the ties are maintained.\nwrite.graph(krack_full, file='krack_full.txt', format=\"edgelist\")",
    "created" : 1480945598648.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3444010801",
    "id" : "8FC3FD0B",
    "lastKnownWriteTime" : 1480950771,
    "last_content_update" : 1480950771408,
    "path" : "~/hackntu2016_sna/lab_1/lab_1.R",
    "project_path" : "lab_1/lab_1.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}